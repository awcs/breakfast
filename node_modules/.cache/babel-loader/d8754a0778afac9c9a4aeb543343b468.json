{"ast":null,"code":"'use strict';\n\nvar queue = Symbol('actions');\n\nmodule.exports.call = function (action, funk) {\n  action[queue] = (action[queue] || []).concat([funk]);\n}; // function from reducer to another reducer\n// the new reducer adds a 'funks' key with declarative effects\n// of type [func, [args]]\n\n\nmodule.exports.coalesceFunks = function (reducer) {\n  return function (state, action) {\n    var nextState = reducer(state, action);\n    var funks = action[queue] || []; // restore action to the way it was\n\n    delete action[queue];\n    return Object.assign({}, nextState, {\n      funks: funks\n    });\n  };\n}; // listen for store updates, and run each funk.\n// `runFunks` assumes that each funk either returns nothing\n// or returns a promise for an action.\n// `runFunks` dispatches the actions\n// You can replace `runFunks` with your own implementation\n// if you prefer callbacks over promises, for example\n\n\nmodule.exports.runFunks = function (store) {\n  store.subscribe(function () {\n    var funks = store.getState().funks || [];\n    funks.forEach(function (funk) {\n      var func = funk[0];\n      var args = funk[1];\n      var maybePromiseForAction = func.apply(null, args);\n\n      if (!maybePromiseForAction || !maybePromiseForAction.then) {\n        return;\n      }\n\n      maybePromiseForAction.then(store.dispatch);\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}